#include "xmk.h"
#include "xtft.h"
#include "xgpio.h"
#include "stdlib.h"
#include "sys/init.h"
#include "xparameters.h"
#include "semaphore.h"
#include <pthread.h>
#include <sys/timer.h> //for using sleep. need to set config_time to true
#include <sys/intr.h> //xilkernel api for interrupts
#include <stdio.h>
#include <limits.h>
#include "TFT_Draw.h"
#include "myButton.h"
#include "xmbox.h"
#include "ballControl.h"
#include "myCommon.h"
#include "myBarrier.h"

/************************** Struct Definition *****************************/

#define XST_SUCCESS                     0L
#define XST_FAILURE                     1L
// TO DO : read and understand the xilkernel system calls as well as the driver APIs used.

#define MBOX_DEVICE_ID		XPAR_MBOX_0_DEVICE_ID

// 5 Priority levels for this processor.
#define PRIO_CONTROLLER 1
#define PRIO_BAR		2
#define PRIO_BALL		3
#define PRIO_COL 		4
#define PRIO_SCORE_ZONE 5

#define SEM_SUCCESS			0
#define UPDATE_COLOUR_SCORE	10
#define MAX_RAND_SLEEP		40 	// for snatching colour sema
/************************** Function Prototypes *****************************/

void* thread_func_controller();
void thread_func_col(int col_x);
void* thread_func_time_elapsed();
void* thread_func_ball();

void changeBrickColour(int score, int colThreads);
unsigned int updateBrickColour(unsigned int currentColour, int col_x) ;

void main_prog(void *arg);

/************************** Variable Definitions ****************************/

/************************** Temp BallSpeed Variable ************************/
static int ballSpeed = 250;
static char flag_colour = 0;
static char flag_ballSpeed = 0;
static int colThreads = 10;
static int init = 1;
/************************** Tft variables ****************************/

static XTft InstancePtr;

/************************** Scheduling variables ****************************/

struct sched_param sched_par;

/************************** Threading variables ****************************/

pthread_attr_t attr;

pthread_t tid_controller, tid_time_elapsed, tid_ball, tid_col_1, tid_col_2,
		tid_col_3, tid_col_4, tid_col_5, tid_col_6, tid_col_7, tid_col_8,
		tid_col_9, tid_col_10;

/************************** Thread Synchronisation variables ****************************/
static XMbox Mbox;

pthread_mutex_t mutex_tft, mutex_timer, mutex_ball;
barrier_t barrier_col;
sem_t sem_colour_yellow;
sem_t sem_colour_background;
/************************** Button variables********************************************/
//volatile char bar_Status;
XGpio gpPB; //PB device instance.

volatile int taskrunning;

int main() {
	print("-- Entering main() --\r\n");

	// Initialise VGA Display...
	tft_init(TFT_DEVICE_ID, &InstancePtr);

	//Initialize Xilkernel
	xilkernel_init();

	//Add main_prog as the static thread that will be invoked by Xilkernel
	xmk_add_static_thread(main_prog, 0);

	//Start Xilkernel
	xilkernel_start();

	/* Never reached */
	return 0;
}

void main_prog(void *arg) {

	int ret, Status;

	// initialize the semaphore
	if (sem_init(&sem_colour_yellow, 0, COL_YELLOW) < 0) // init sem_colour_yellow with 2 resource
			{
		print("Error while initializing semaphore sem.\r\n");
	}

	// initialize the semaphore
	if (sem_init(&sem_colour_background, 0, COL_BACKGROUND) < 0) // init sem_colour_background with 8 resource
			{
		print("Error while initializing semaphore sem.\r\n");
	}

	// initialize barrier
	ret = myBarrier_init(&barrier_col, COL_BRICKS + 1); // barrier is for # of col threads + controller thread (1)
	if (ret != 0) {
		xil_printf("-- ERROR (%d) init barrier...\r\n", ret);
	}

	// initialize mutex
	ret = pthread_mutex_init(&mutex_tft, NULL );
	if (ret != 0) {
		xil_printf("-- ERROR (%d) init uart_mutex...\r\n", ret);
	}

	ret = pthread_mutex_init(&mutex_timer, NULL );
	if (ret != 0) {
		xil_printf("-- ERROR (%d) init uart_mutex...\r\n", ret);
	}

	ret = pthread_mutex_init(&mutex_ball, NULL );
	if (ret != 0) {
		xil_printf("-- ERROR (%d) init uart_mutex...\r\n", ret);
	}


	pthread_mutex_lock(&mutex_timer);
	pthread_mutex_lock(&mutex_ball);

	init_myButton(&gpPB);

	/************************** Mailbox Init ****************************/

	XMbox_Config *ConfigPtr;

	ConfigPtr = XMbox_LookupConfig(MBOX_DEVICE_ID);
	if (ConfigPtr == (XMbox_Config *) NULL ) {
		print("-- Error configuring Mbox uB1 Sender--\r\n");
		//return XST_FAILURE;
	}

	Status = XMbox_CfgInitialize(&Mbox, ConfigPtr, ConfigPtr->BaseAddress);
	if (Status != XST_SUCCESS) {
		print("-- Error initializing Mbox uB1 Sender--\r\n");
		//return XST_FAILURE;
	}
	//print("startinitDraw");
	tft_intialDraw(&InstancePtr);
	//	print("end init");

	tft_updateSpeed(&InstancePtr, ballSpeed);
	tft_updateBricksLeft(&InstancePtr, 80);
	tft_updateScore(&InstancePtr, 0);
//	int speed;
//	while(1)
//	{
//		tft_moveCircle(&InstancePtr);
//		speed = myBallControl_SpeedChange()
//		tft_moveCircle
//	}

	pthread_attr_init(&attr);					// get attribute for thread.

	//pthread_barrier_init(&barrier, NULL, 11); // barrier of size 11, for 10 col threads + 1 update display

	/************************** Controller Threads Init ****************************/

	sched_par.sched_priority = PRIO_CONTROLLER; // set priority for controller thread
	pthread_attr_setschedparam(&attr, &sched_par); // update priority attribute

	//start controller thread 1
	ret = pthread_create(&tid_controller, NULL, (void*) thread_func_controller,
			NULL );
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_1...\r\n", ret);
	} else {
		xil_printf("Controller Thread launched with ID %d \r\n",
				tid_controller);
	}

	/************************** Column Threads Init ****************************/

	sched_par.sched_priority = PRIO_COL; // set priority for columns thread
	pthread_attr_setschedparam(&attr, &sched_par); // update priority attribute

	//start col thread 1
	ret = pthread_create(&tid_col_1, NULL, (void*) thread_func_col,
	COL_1_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_1...\r\n", ret);
	} else {
		xil_printf("Col Thread 1 launched with ID %d \r\n", tid_col_1);
	}

	//start col thread 2
	ret = pthread_create(&tid_col_2, NULL, (void*) thread_func_col,
	COL_2_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_2...\r\n", ret);
	} else {
		xil_printf("Col Thread 2 launched with ID %d \r\n", tid_col_2);
	}

	//start thread 3
	ret = pthread_create(&tid_col_3, NULL, (void*) thread_func_col,
	COL_3_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_3...\r\n", ret);
	} else {
		xil_printf("Col Thread 3 launched with ID %d \r\n", tid_col_3);
	}

	//start thread 4
	ret = pthread_create(&tid_col_4, NULL, (void*) thread_func_col,
	COL_4_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_4...\r\n", ret);
	} else {
		xil_printf("Col Thread 4 launched with ID %d \r\n", tid_col_4);
	}

	//start thread 5
	ret = pthread_create(&tid_col_5, NULL, (void*) thread_func_col,
	COL_5_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_5...\r\n", ret);
	} else {
		xil_printf("Col Thread 5 launched with ID %d \r\n", tid_col_5);
	}

	ret = pthread_create(&tid_col_6, NULL, (void*) thread_func_col,
	COL_6_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_6...\r\n", ret);
	} else {
		xil_printf("Col Thread 6 launched with ID %d \r\n", tid_col_6);
	}

	ret = pthread_create(&tid_col_7, NULL, (void*) thread_func_col,
	COL_7_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_7...\r\n", ret);
	} else {
		xil_printf("Col Thread 7 launched with ID %d \r\n", tid_col_7);
	}

	ret = pthread_create(&tid_col_8, NULL, (void*) thread_func_col,
	COL_8_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_8...\r\n", ret);
	} else {
		xil_printf("Col Thread 8 launched with ID %d \r\n", tid_col_8);
	}

	ret = pthread_create(&tid_col_9, NULL, (void*) thread_func_col,
	COL_9_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_9...\r\n", ret);
	} else {
		xil_printf("Col Thread 9 launched with ID %d \r\n", tid_col_9);
	}

	ret = pthread_create(&tid_col_10, NULL, (void*) thread_func_col,
	COL_10_X);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_func_col_10...\r\n", ret);
	} else {
		xil_printf("Col Thread 10 launched with ID %d \r\n", tid_col_10);
	}

	sched_par.sched_priority = PRIO_SCORE_ZONE; // set priority for score zone threads
	pthread_attr_setschedparam(&attr, &sched_par); // update priority attribute

	/************************ TIMER INIT *************************/

	//start timer thread. (SHOULD NOT BE HERE ON ACTUAL PROJECT !!! Launch ball => then start this thread..)
	ret = pthread_create(&tid_time_elapsed, NULL,
			(void*) thread_func_time_elapsed, 0);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_time_elapsed...\r\n", ret);
	} else {
		xil_printf("Col Thread 1 launched with ID %d \r\n", tid_col_1);
	}

	/************************ Update ball INIT *************************/

	sched_par.sched_priority = PRIO_BALL; // set priority for score zone threads
	pthread_attr_setschedparam(&attr, &sched_par); // update priority attribute

	ret = pthread_create(&tid_ball, NULL, (void*) thread_func_ball, 0);
	if (ret != 0) {
		xil_printf("-- ERROR (%d) launching thread_time_elapsed...\r\n", ret);
	} else {
		xil_printf("Col Thread 1 launched with ID %d \r\n", tid_col_1);
	}

}

void* thread_func_controller() {

	// semaphore release
	int score = 0, tempScore = 0;
	//int colThreads = COL_BRICKS; // Number of column threads = how many column of bricks.
	int buttonHoldTime = 0;

	/********************* TEMP SECTION FOR MS 1 ******************/

	myBarrier_wait(&barrier_col); // allows printing of bricks 1st

	while (!myButton_checkCenter(&gpPB)) {
		sleep(10); // wait for middle button to press to start game...

	}
	pthread_mutex_unlock(&mutex_timer); // release timer mutex to start time for game..

	/********************* TEMP SECTION FOR MS 1 ******************/

	while (1) {

		/********************* TEMP SECTION FOR MS 1 ******************/

//		pthread_mutex_lock(&mutex_tft); // may not be needed...
		tft_updateScore(&InstancePtr, score); // temp score increment per frame...
		if(flag_colour == 1)
		{
			changeBrickColour(score, colThreads);
			flag_colour = 0;
		}
//		pthread_mutex_unlock(&mutex_tft);

		if (score != 0 && score % 10 == 0) // note this is temp.. score can + 2...
		{
			if(flag_ballSpeed == 0)
			{
				flag_ballSpeed = 1;
				ballSpeed += 25;
			}
		}
		else
		{
			flag_ballSpeed = 0;
		}

		tft_updateSpeed(&InstancePtr, ballSpeed);

		pthread_mutex_unlock(&mutex_ball); // start processing ball...

		tempScore++;

		if (!(tempScore % 10))
		{
			score++;
			flag_colour = 1; // update the colour...
		}
		/********************* TEMP SECTION FOR MS 1 ******************/

		// mailbox should be here....
		// update score should be here, print score somwhere else...
		// score updated => update colour.. then fire all col threads.
		myBarrier_wait(&barrier_col); // "fire" all col threads

		print("I am controller\n");

		if (myButton_checkLeft(&gpPB)) {
			//xil_printf("lapsed time is : %d\r\n", myButton_checkLeft(&gpPB));
			buttonHoldTime = myButton_checkLeft(&gpPB);
			tft_moveBarLeft(&InstancePtr, buttonHoldTime);
			//tft_addCircle(&InstancePtr, CIRCLE_X, CIRCLE_Y, 15);

		}

		if (myButton_checkRight(&gpPB)) {
			//xil_printf("lapsed time is : %d\r\n", myButton_checkRight(&gpPB));
			buttonHoldTime = myButton_checkRight(&gpPB);
			tft_moveBarRight(&InstancePtr, buttonHoldTime);
		}

		sleep(40); // sleep 40 ms

	}

}

void* thread_func_time_elapsed() {
	time_t startTime, timeElapsed, gameTime, prevGameTime;

	sys_time(&startTime); // get start time of the game

	pthread_mutex_lock(&mutex_timer); // let's wait for game to start...

	while (1) {
		sys_time(&timeElapsed); // get time elapsed so far...

		if (timeElapsed < startTime) {
			// over flow ... handle it !
			gameTime = LONG_MAX - timeElapsed - startTime; // max time = LONG_MAX
		} else {
			gameTime = timeElapsed - startTime;
		}

		if (prevGameTime != gameTime) {
			// update time box (function needed !!!)
			pthread_mutex_lock(&mutex_tft);
			tft_updateTime(&InstancePtr, gameTime);
			pthread_mutex_unlock(&mutex_tft);

			prevGameTime = gameTime;
		}

		sleep(1000); // sleep 1000 ms (1 sec) 

	}
}

void thread_func_col(int col_x)
{
	unsigned int currentColour = COLOR_GREEN; // some default color.
	unsigned int futureColour = COLOR_GREEN; // some default color.

	unsigned char currentBricks = 0; 		  // start with 0 bricks..
	unsigned char futureBricks = 0b11111111; // after updateColumn will have 8 col brick!!!
	unsigned char randBricks;

	unsigned int thread_ScoreAccumulated = 0;


	ball_msg ball; // ball param received from mailbox

	do
	{
		// some msg q or ....... semaphore.... or .....
		// check if ball hit brick => update score, future brick
		// check if picked randomly => update colour
		// test print

		// add mailbox to blockingReceive (wait) for updated ball param to satisfy (fps)
		//XMbox_ReadBlocking(&Mbox, &ball, sizeof(ball_msg));

		print("we are waiting");
		myBarrier_wait(&barrier_col); // wait for all col threads to reach here... and controller thread to reach wait.
		xil_printf("I am column %d\n", col_x);

		thread_ScoreAccumulated++;

		if (init == 0)
		{
			futureColour = updateBrickColour(currentColour, col_x);
		}

		pthread_mutex_lock(&mutex_tft);
		//	xil_printf ("\r\nThis is Col :  %d \r", col_x);
		tft_updateColumn(&InstancePtr, col_x, currentBricks, futureBricks,
				currentColour, futureColour);

		pthread_mutex_unlock(&mutex_tft);

		currentColour = futureColour;
		currentBricks = futureBricks;

		if (!init && (thread_ScoreAccumulated % 50 == 0))
		{
			randBricks = rand() % 256;

			if (randBricks < currentBricks)
				futureBricks = randBricks;
		}


		//		xil_printf ("\r\nend is Col :  %d \r", col_x);

		// some msgq or semaphore to indicate completion of rebounce and bar param
		// writeBlocking send it back.

		//pthread_exit(0);
	}while(currentBricks != 0);

	// pthread_exited...


	  myBarrier_decreaseSize(&barrier_col);

	  pthread_mutex_lock(&mutex_tft);
	  colThreads --;
	  pthread_mutex_unlock(&mutex_tft);

	  xil_printf ("\r\n col threads is :  %d \r", colThreads);


}

void* thread_func_ball() {
	ball_msg ball;
	ball.x = CIRCLE_X;
	ball.y = CIRCLE_Y;
	ball.dir = 90; // 90 degree

	int ballSpeedPerFrame = 0;

	while (1) {
		pthread_mutex_lock(&mutex_ball);

		ballSpeedPerFrame = myBallControl_getBallSpeedPerFrame(ballSpeed); // get speed per frame

		pthread_mutex_lock(&mutex_tft);
		tft_removeCircle(&InstancePtr, ball.x, ball.y, CIRCLE_RADIUS); // update ball location...
		pthread_mutex_unlock(&mutex_tft);

		ball = myBallControl_getBallLocation(ballSpeedPerFrame, ball); // get end ball location..

		// .. add some boundary so ball will bounce up and down.... irregardless of brick and 
		if (ball.y < 228) {
			ball.y = 228;
			ball.dir = ball.dir * -1;
		}

		if (ball.y > 397) {
			ball.y = 395;
			ball.dir = ball.dir * -1;
		}
		//xil_printf("bsp = %d, ball.x = %d\r\nball.y = %d\r\n",ballSpeedPerFrame, ball.x, ball.y);

		pthread_mutex_lock(&mutex_tft);
		tft_addCircle(&InstancePtr, ball.x, ball.y, CIRCLE_RADIUS); // update ball location...
		pthread_mutex_unlock(&mutex_tft);
	}

}
// Simple Description : Release semaphore resource for brick colour change.
void changeBrickColour(int score, int colThreads) {
	int i, semaRelease;


	//	print("Starting Here\r\n");
	//	xil_printf("score: %d", score);
	if (score != 0 && score % 10 == 0)
	{
		init = 0;

		xil_printf("score is %d\n", score);
		//	print("inside loop liao");
		//release 2 semaphore yellow colour resources!!!

		if (colThreads > COL_YELLOW) {
			// some col need to be green
			semaRelease = colThreads - COL_YELLOW;
			for (i = 0; i < semaRelease; i++) {
				// release semaphore to change to background
				sem_post(&sem_colour_background);
			}
		}

		if (colThreads < COL_YELLOW) {
			// lesser thread than column to be yellow.. release lesser sema.
			for (i = 0; i < colThreads; i++) {
				// release semaphore to change to background

				xil_printf("releasing in < col yellow\n");
				sem_post(&sem_colour_yellow);
			}
		} else {
			for (i = 0; i < COL_YELLOW; i++) {
				// release semaphore to change to background

				xil_printf("releasing in > yellow\n");
				sem_post(&sem_colour_yellow);
			}
		}
	}
}

// Simple Description : Snatch for 2 semaphore resource, fail then colour same..
unsigned int updateBrickColour(unsigned int currentColour, int col_x) {

	sleep(rand() % MAX_RAND_SLEEP);


	if (sem_trywait(&sem_colour_yellow) == SEM_SUCCESS) {
		// resource snatched !
		xil_printf("snatched resouce.!\n col x is : %d\n" , col_x);
		return COLOR_YELLOW;
	} else {
		if (sem_trywait(&sem_colour_background) == SEM_SUCCESS) {
			// failed to snatched resource
			return COLOR_GREEN;
		} else {
			// nothing to snatch
			return currentColour;

		}

	}

}

//void do_something(int max, int ID) {
//  sem_wait(&sem);
//  int i;
//  count++;
//  pthread_mutex_lock (&mutex);
//
//    changeBarColor(ID, COLOR_RED);
//    xil_printf ("\r\nNew Column Turn Red !! Red Columns Count :  %d \r", count);
//
//  pthread_mutex_unlock (&mutex);
//  if (taskrunning != ID) {
//      taskrunning = ID;}
//  pthread_mutex_lock (&mutex);
//  xil_printf ("\r\n Column %d Turn Red !! \r\n", ID);
//  pthread_mutex_unlock (&mutex);
//  for(i=0; i< max; i++)
//  {
//	  sleep(3);
//  }
//
//
//  sleep(MIN_DELAY);
//
//  count--;
//
//    pthread_mutex_lock (&mutex);
//        changeBarColor(ID, COLOR_BLUE);
//        xil_printf ("\r\n Column %d back to normal !! Red Columns Count :  %d \r",ID,count);
//     pthread_mutex_unlock (&mutex);
//
//   sem_post(&sem);
//}

//void* thread_func_1 () {
//  while(1) {
//
//    do_something((rand() % MAX_RAND_DELAY), 1);
//  }
//}
//
//
//void* thread_func_2 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 2);
//  }
//}
//
//
//void* thread_func_3 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 3);
//  }
//}
//
//
//void* thread_func_4 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 4);
//  }
//}
//
//void* thread_func_5 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 5);
//  }
//}
//
//void* thread_func_6 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 6);
//  }
//}
//void* thread_func_7 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 7);
//  }
//}
//void* thread_func_8 () {
//  while(1) {
//	  do_something((rand() % MAX_RAND_DELAY), 8);
//  }
//}
//
//
///*****************************************************************************/
///**
//* Change Bar color based on thread id
//*
//* @param  threadID is the id for the thread
//* @param  color is the color to change the column brick
//*
//* @return
//*   - XST_SUCCESS if successful.
//*   - XST_FAILURE if unsuccessful.
//*
//*
//******************************************************************************/
//int changeBarColor(int threadID, u32 colour)
//{
//
//  switch (threadID)
//  {
//    case 1:
//            TftDrawLine(&TftInstance, T1_BAR_X, ALL_BAR_Y, T1_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 1
//            break;
//
//    case 2:
//            TftDrawLine(&TftInstance, T2_BAR_X, ALL_BAR_Y, T2_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 2
//            break;
//    case 3:
//            TftDrawLine(&TftInstance, T3_BAR_X, ALL_BAR_Y, T3_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 3
//            break;
//    case 4:
//            TftDrawLine(&TftInstance, T4_BAR_X, ALL_BAR_Y, T4_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 4
//            break;
//    case 5:
//            TftDrawLine(&TftInstance, T5_BAR_X, ALL_BAR_Y, T5_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 5
//            break;
//    case 6:
//            TftDrawLine(&TftInstance, T6_BAR_X, ALL_BAR_Y, T6_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 6
//            break;
//    case 7:
//            TftDrawLine(&TftInstance, T7_BAR_X, ALL_BAR_Y, T7_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 7
//            break;
//    case 8:
//            TftDrawLine(&TftInstance, T8_BAR_X, ALL_BAR_Y, T8_BAR_X, ALL_BAR_Y + ALL_BAR_HEIGHT, colour); // column 8
//            break;
//
//    default: ;
//  }
//
//
//}

